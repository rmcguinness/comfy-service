package api

import (
	"fmt"
	"log"
	"net/http"
	"path/filepath"

	"comfyui-api-service/comfyui" // Import your local comfyui package

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// APIHandler holds dependencies like the ComfyUI client.
type APIHandler struct {
	ComfyClient *comfyui.Client
}

// NewAPIHandler creates a new handler instance.
func NewAPIHandler(client *comfyui.Client) *APIHandler {
	return &APIHandler{
		ComfyClient: client,
	}
}

// QueuePromptRequest represents the expected JSON body for queueing a prompt.
// We need this separate struct for Swaggo documentation.
type QueuePromptRequest struct {
	Prompt map[string]interface{} `json:"prompt" binding:"required" example:"{\"3\": {\"inputs\": {\"seed\": 123, \"steps\": 20}}}"` // Example structure
}

// QueuePrompt godoc
// @Summary      Queue a generation prompt
// @Description  Sends a workflow prompt to the ComfyUI backend for processing.
// @Tags         ComfyUI
// @Accept       json
// @Produce      json
// @Param        prompt body QueuePromptRequest true "The prompt workflow JSON and client ID"
// @Success      200  {object} comfyui.PromptResponse "Successfully queued prompt"
// @Failure      400  {object} gin.H "Bad Request (e.g., invalid JSON)"
// @Failure      401  {object} gin.H "Unauthorized (Invalid or missing Bearer token)"
// @Failure      500  {object} gin.H "Internal Server Error (e.g., ComfyUI unreachable)"
// @Security     BearerAuth
// @Router       /queue_prompt [post]
func (h *APIHandler) QueuePrompt(c *gin.Context) {
	var req QueuePromptRequest

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body", "details": err.Error()})
		return
	}

	// Use the Comfy Client - use ClientID from client or generate new one if needed
	resp, err := h.ComfyClient.QueuePrompt(req.Prompt) // Uses client's default ID
	if err != nil {
		log.Printf("Error queueing prompt: %v", err)
		// Distinguish between client errors (e.g., ComfyUI down) and other errors
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to queue prompt", "details": err.Error()})
		return
	}

	c.JSON(http.StatusOK, resp)
}

// GetHistory godoc
// @Summary      Get prompt history
// @Description  Retrieves the execution history and outputs for a specific prompt ID.
// @Tags         ComfyUI
// @Produce      json
// @Param        prompt_id path string true "The ID of the prompt" Format(uuid) example("a1b2c3d4-e5f6-7890-1234-567890abcdef")
// @Success      200  {object} map[string]interface{} "Prompt history details"
// @Failure      401  {object} gin.H "Unauthorized (Invalid or missing Bearer token)"
// @Failure      404  {object} gin.H "Not Found (Prompt ID not found in ComfyUI)"
// @Failure      500  {object} gin.H "Internal Server Error"
// @Security     BearerAuth
// @Router       /history/{prompt_id} [get]
func (h *APIHandler) GetHistory(c *gin.Context) {
	promptID := c.Param("prompt_id")
	if promptID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "prompt_id path parameter is required"})
		return
	}

	history, err := h.ComfyClient.GetHistory(promptID)
	if err != nil {
		log.Printf("Error getting history for prompt %s: %v", promptID, err)
		// Basic check if the error indicates not found (depends on comfyui client error wrapping)
		if strings.Contains(err.Error(), "status: 404 Not Found") { // Example check
			c.JSON(http.StatusNotFound, gin.H{"error": "Prompt history not found", "prompt_id": promptID})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get prompt history", "details": err.Error()})
		}
		return
	}

	if history == nil || len(history) == 0 {
		// Might be redundant if the client call already handles 404, but safe to check.
		c.JSON(http.StatusNotFound, gin.H{"error": "Prompt history not found or empty", "prompt_id": promptID})
		return
	}

	c.JSON(http.StatusOK, history)
}

// GetImage godoc
// @Summary      Get generated image
// @Description  Downloads a specific image generated by ComfyUI.
// @Tags         ComfyUI
// @Produce      image/png
// @Produce      image/jpeg
// @Param        filename  query string true "Filename of the image" example("ComfyUI_00001_.png")
// @Param        subfolder query string false "Subfolder containing the image (if any)" example("output")
// @Param        type      query string true "Type of image (e.g., 'output', 'input', 'temp')" example("output") Enums(output, input, temp)
// @Success      200  {file} file "The requested image file"
// @Failure      400  {object} gin.H "Bad Request (Missing required query parameters)"
// @Failure      401  {object} gin.H "Unauthorized"
// @Failure      404  {object} gin.H "Not Found (Image not found on ComfyUI server)"
// @Failure      500  {object} gin.H "Internal Server Error"
// @Security     BearerAuth
// @Router       /image [get]
func (h *APIHandler) GetImage(c *gin.Context) {
	filename := c.Query("filename")
	folderType := c.Query("type") // e.g., "output", "input", "temp"
	subfolder := c.Query("subfolder") // Optional

	if filename == "" || folderType == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Missing required query parameters: filename, type"})
		return
	}

	imageData, err := h.ComfyClient.GetImage(filename, subfolder, folderType)
	if err != nil {
		log.Printf("Error getting image '%s': %v", filename, err)
		if strings.Contains(err.Error(), "status: 404 Not Found") { // Example check
			c.JSON(http.StatusNotFound, gin.H{"error": "Image not found"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get image", "details": err.Error()})
		}
		return
	}

	// Determine content type based on filename extension (basic)
	contentType := "application/octet-stream" // Default
	ext := strings.ToLower(filepath.Ext(filename))
	switch ext {
	case ".png":
		contentType = "image/png"
	case ".jpg", ".jpeg":
		contentType = "image/jpeg"
	case ".webp":
		contentType = "image/webp"
	}

	c.Data(http.StatusOK, contentType, imageData)
}

// UploadImage godoc
// @Summary      Upload an image
// @Description  Uploads an image file to the ComfyUI input directory.
// @Tags         ComfyUI
// @Accept       multipart/form-data
// @Produce      json
// @Param        image      formData file   true  "Image file to upload"
// @Param        type       formData string true  "Type of upload (usually 'input')" example("input") Enums(input, temp)
// @Param        overwrite  formData bool   false "Overwrite existing file (default: false)" example(false)
// @Success      200 {object} comfyui.UploadImageResponse "Image uploaded successfully"
// @Failure      400 {object} gin.H "Bad Request (e.g., missing file or type)"
// @Failure      401 {object} gin.H "Unauthorized"
// @Failure      500 {object} gin.H "Internal Server Error (e.g., upload failed)"
// @Security     BearerAuth
// @Router       /upload_image [post]
func (h *APIHandler) UploadImage(c *gin.Context) {
	imageType := c.PostForm("type")
	overwriteStr := c.PostForm("overwrite") // Defaults to "false" if not present
	overwrite := overwriteStr == "true"

	if imageType == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Form field 'type' is required"})
		return
	}

	fileHeader, err := c.FormFile("image")
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Form field 'image' (file) is required", "details": err.Error()})
		return
	}

	// Save uploaded file to a temporary location to pass its path to the client
	// Alternatively, the comfyui client could be modified to accept an io.Reader
	tmpFileName := filepath.Join(os.TempDir(), fmt.Sprintf("upload_%s_%s", uuid.NewString(), fileHeader.Filename))
	if err := c.SaveUploadedFile(fileHeader, tmpFileName); err != nil {
		log.Printf("Error saving temporary upload file: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process uploaded file", "details": err.Error()})
		return
	}
	defer func() {
		if err := os.Remove(tmpFileName); err != nil {
			log.Printf("Warning: failed to remove temporary upload file %s: %v", tmpFileName, err)
		}
	}() // Clean up temp file

	// Use the original filename for the ComfyUI upload 'name' parameter
	uploadResp, err := h.ComfyClient.UploadImage(tmpFileName, fileHeader.Filename, imageType, overwrite)
	if err != nil {
		log.Printf("Error uploading image to ComfyUI: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to upload image", "details": err.Error()})
		return
	}

	c.JSON(http.StatusOK, uploadResp)
}